{"version":3,"file":"array-nonindex-keys.umd.cjs","sources":["../../presets/array-nonindex-keys.js"],"sourcesContent":["/**\n * @type {import('typeson').Preset}\n */\nconst arrayNonindexKeys = [\n    {\n        arrayNonindexKeys: {\n            testPlainObjects: true,\n            test (x, stateObj) {\n                if (Array.isArray(x)) {\n                    if (\n                        // By avoiding serializing arrays into objects which\n                        //  have only positive-integer keys, we reduce\n                        //  size and improve revival performance; arrays with\n                        //  non-index keys will be larger however\n                        Object.keys(x).some((k) => {\n                            //  No need to check for `isNaN` or\n                            //   `isNaN(Number.parseInt())` as `NaN` will be\n                            //   treated as a string.\n                            //  No need to do check as\n                            //   `Number.parseInt(Number())` since scientific\n                            //   notation will be pre-resolved if a number\n                            //   was given, and it will otherwise be a string\n                            return String(Number.parseInt(k)) !== k;\n                        })\n                    ) {\n                        stateObj.iterateIn = 'object';\n                        stateObj.addLength = true;\n                    }\n                    return true;\n                }\n                return false;\n            },\n            replace (a, stateObj) {\n                // Catch sparse undefined\n                stateObj.iterateUnsetNumeric = true;\n                return a;\n            },\n            revive (o) {\n                if (Array.isArray(o)) {\n                    return o;\n                }\n\n                /**\n                 * @type {{[key: string]: any}}\n                 */\n                const arr = [];\n                // No map here as may be a sparse array (including\n                //   with `length` set)\n                Object.entries(o).forEach(([key, val]) => {\n                    arr[key] = val;\n                });\n                return arr;\n            }\n        }\n    },\n    {\n        sparseUndefined: {\n            test (x, stateObj) {\n                return typeof x === 'undefined' && stateObj.ownKeys === false;\n            },\n            replace (/* n */) { return 0; },\n            revive (/* s */) { return undefined; } // Will avoid adding anything\n        }\n    }\n];\n\nexport default arrayNonindexKeys;\n"],"names":["arrayNonindexKeys","testPlainObjects","test","x","stateObj","Array","isArray","Object","keys","some","k","String","Number","parseInt","iterateIn","addLength","replace","a","iterateUnsetNumeric","revive","o","arr","entries","forEach","_ref","_ref2","_slicedToArray","key","val","sparseUndefined","ownKeys"],"mappings":"u6CAG0B,CACtB,CACIA,kBAAmB,CACfC,kBAAkB,EAClBC,KAAIA,SAAAA,KAAEC,EAAGC,GACL,QAAIC,MAAMC,QAAQH,KAMVI,OAAOC,KAAKL,GAAGM,MAAK,SAACC,GAQjB,OAAOC,OAAOC,OAAOC,SAASH,MAAQA,CAC1C,MAEAN,EAASU,UAAY,SACrBV,EAASW,WAAY,IAElB,EAGd,EACDC,QAAOA,SAAAA,QAAEC,EAAGb,GAGR,OADAA,EAASc,qBAAsB,EACxBD,CACV,EACDE,OAAM,SAAAA,OAAEC,GACJ,GAAIf,MAAMC,QAAQc,GACd,OAAOA,EAMX,IAAMC,EAAM,GAMZ,OAHAd,OAAOe,QAAQF,GAAGG,SAAQ,SAAAC,GAAgB,IAAAC,EAAAC,eAAAF,EAAA,GAAdG,EAAGF,EAAA,GAAEG,EAAGH,EAAA,GAChCJ,EAAIM,GAAOC,CACf,IACOP,CACX,IAGR,CACIQ,gBAAiB,CACb3B,KAAIA,SAAAA,KAAEC,EAAGC,GACL,YAAoB,IAAND,IAA0C,IAArBC,EAAS0B,OAC/C,EACDd,QAAO,SAAAA,UAAa,OAAO,CAAI,EAC/BG,OAAM,SAAAA,SAAgC"}