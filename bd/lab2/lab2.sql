-- Запросы для создания таблиц студентов и групп

CREATE TABLE students (
    id NUMBER,
    name varchar2,
    group_id NUMBER
);

CREATE TABLE groups (
    id NUMBER,
    name varchar2,
    c_val NUMBER
);

-- Триггеры для проверки на уникальность идентификаторов студентов и групп и имен групп

CREATE OR REPLACE TRIGGER check_groups_name_unique
BEFORE INSERT OR UPDATE ON groups
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM groups
    WHERE name = :NEW.name;

    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Имя группы должно быть уникальным.');
    END IF;
END;

CREATE OR REPLACE TRIGGER check_groups_id_unique
BEFORE INSERT OR UPDATE ON groups
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM groups
    WHERE id = :NEW.id;

    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Идентификатор группы должен быть уникальным.');
    END IF;
END;

CREATE OR REPLACE TRIGGER check_students_id_unique
BEFORE INSERT OR UPDATE ON students
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM students
    WHERE id = :NEW.id;

    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Идентификатор студента должен быть уникальным.');
    END IF;
END;

-- Триггеры для генерации автоинкрементного ключа

CREATE SEQUENCE students_seq
START WITH 1
INCREMENT BY 1
NOCACHE;

CREATE OR REPLACE TRIGGER autoincrement_students
BEFORE INSERT ON students
FOR EACH ROW
BEGIN
    SELECT students_seq.nextval INTO :NEW.id FROM dual;
END;

CREATE SEQUENCE groups_seq
START WITH 1
INCREMENT BY 1
NOCACHE;

CREATE OR REPLACE TRIGGER autoincrement_groups
BEFORE INSERT ON groups
FOR EACH ROW
BEGIN
    SELECT groups_seq.nextval INTO :NEW.id FROM dual;
END;

-- Триггер реализующий каскадное удаление студентов при удалении группы

CREATE OR REPLACE TRIGGER students_fk
BEFORE DELETE ON groups
FOR EACH ROW
BEGIN
    DELETE FROM students WHERE group_id = :OLD.id;
END;

-- Таблица журнала

CREATE TABLE students_audit (
    audit_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    action_type VARCHAR2(10),
    student_id NUMBER,
    student_name VARCHAR2(100),
    group_id NUMBER,
    action_date TIMESTAMP
);

-- Триггер для журналирования всех действий

CREATE OR REPLACE TRIGGER students_audit
AFTER INSERT OR UPDATE OR DELETE ON students
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO students_audit (action_type, student_id, student_name, group_id, action_date)
        VALUES ('INSERT', :NEW.id, :NEW.name, :NEW.group_id, SYSDATE);
    ELSIF UPDATING THEN
        INSERT INTO students_audit (action_type, student_id, student_name, group_id, action_date)
        VALUES ('UPDATE', :OLD.id, :OLD.name, :OLD.group_id, SYSDATE);
    ELSIF DELETING THEN
        INSERT INTO students_audit (action_type, student_id, student_name, group_id, action_date)
        VALUES ('DELETE', :OLD.id, :OLD.name, :OLD.group_id, SYSDATE);
    END IF;
END;

-- Процедура для восстановления информации на указанный временной момент и на временное смещение

CREATE OR REPLACE PROCEDURE restore_students_data(
    p_action_date TIMESTAMP,
    p_offset INTERVAL DEFAULT INTERVAL '0' DAY TO SECOND)
AS
BEGIN
    SELECT *
    FROM students_audit
    AS OF TIMESTAMP (p_action_date + p_offset);
END;

-- Пример использования журнала

EXECUTE restore_students_data(p_action_date => TIMESTAMP '2024-03-11 12:00:00', p_offset => INTERVAL '1' HOUR);

-- Триггер для обновления информации C_VAL при изменении данных в таблице STUDENTS

CREATE OR REPLACE TRIGGER update_groups_cval
AFTER INSERT OR UPDATE OR DELETE ON students
FOR EACH ROW
BEGIN
    UPDATE groups g
    SET g.c_val = (SELECT COUNT(*) FROM students s WHERE s.group_id = :NEW.group_id)
    WHERE g.id = :NEW.group_id;
END;